<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>График именин</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        /* Стиль для увеличения кликабельной области в легенде */
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .today-namedays {
            text-align: left;
            margin-bottom: 20px;
            padding: 10px;
        }
        .today-namedays-list {
            font-size: 20px;
        }
        .input-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .names-input {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            resize: vertical;
        }
        .button-section {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        .share-button {
            background-color: #2196F3;
        }
        .share-button:hover {
            background-color: #0b7dda;
        }
        .chart-container {
            height: 500px;
            margin-top: 20px;
        }
        
        /* Styles for custom legend */
        .custom-legend-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
            padding: 10px 0;
        }
        .custom-legend-item {
            display: flex;
            align-items: center;
            margin: 8px 15px;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .custom-legend-item:hover {
            background-color: #f0f0f0;
        }
        .custom-legend-color {
            width: 60px;
            height: 4px;
            margin-right: 8px;
        }
        .custom-legend-label {
            font-size: 14px;
            font-weight: 500;
        }
        .custom-legend-item.hidden .custom-legend-color {
            opacity: 0.4;
        }
        .custom-legend-item.hidden .custom-legend-label {
            opacity: 0.6;
        }
        .loading {
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
            display: none;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #666;
        }
        .error-message {
            color: #d9534f;
            text-align: center;
            margin-top: 20px;
            display: none;
        }
        .share-link {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            word-break: break-all;
            display: none;
        }
        .nameday-ranking {
            margin-top: 30px;
            width: 100%;
            border-collapse: collapse;
        }
        .nameday-ranking th, .nameday-ranking td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .nameday-ranking th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .nameday-ranking tr:hover {
            background-color: #f5f5f5;
        }
        .today-nameday {
            color: #4CAF50;
            font-weight: bold;
        }
        .person-card {
            border: 1px solid #ccc;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .person-card h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .person-card label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .person-card input[type="text"] {
            width: calc(100% - 22px); /* Adjust for padding and border */
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .relatives-section {
            margin-left: 20px;
            margin-top: 10px;
            padding-left: 15px;
            border-left: 2px solid #eee;
        }
        .relatives-section h5 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #555;
        }
        .relative-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .relative-input-group input[type="text"] {
            flex-grow: 1;
            margin-bottom: 0; /* Override person-card input margin */
            margin-right: 5px;
        }
        .remove-btn {
            padding: 5px 8px;
            background-color: #d9534f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .remove-btn:hover {
            background-color: #c9302c;
        }
        .add-relative-btn {
            padding: 6px 10px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }
        .add-relative-btn:hover {
            background-color: #4cae4c;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Именины сегодня</h2>
        <div id="today-namedays" class="today-namedays">    
            <div id="today-namedays-list" class="today-namedays-list">Загрузка...</div>
        </div>
        
        <h2>График именин</h2>
        <div class="input-section">
            <button type="button" id="toggle-people-editor-btn" style="margin-bottom: 10px; background-color: #f0f0f0; color: #333; border: 1px solid #ccc;">Скрыть форму добавления людей</button>
            <div id="people-editor-collapsible" style="display: block;"> 
                <div id="people-input-area">
                    <!-- Сюда будут добавляться карточки для каждого человека -->
                </div>
                <button type="button" id="add-person-btn" style="margin-top: 10px;">+ Добавить человека</button>
            </div>
        </div>
        
        <div class="input-section" style="flex-direction: row; align-items: center; justify-content: center; margin-bottom: 10px;">
            <input type="checkbox" id="include-relatives-checkbox" checked style="margin-right: 8px;">
            <label for="include-relatives-checkbox">Учитывать родственников</label>
        </div>
        
        <div class="button-section">
            <button id="generate-chart">Построить график</button>
            <button id="share-button" class="share-button">Поделиться</button>
        </div>
        
        <div id="share-link" class="share-link"></div>
        <div id="loading" class="loading">Загрузка данных...</div>
        <div id="error-message" class="error-message"></div>
        
        <div class="chart-container">
            <canvas id="namedays-chart"></canvas>
        </div>
        
        <div id="custom-legend" class="custom-legend-container">
            <!-- Custom legend will be added here dynamically -->
        </div>
        
        <div class="ranking-container">
            <h2>Рейтинг именин</h2>
            <table id="nameday-ranking" class="nameday-ranking">
                <thead>
                    <tr>
                        <th>Имя</th>
                        <th>Количество именин</th>
                        <th>Получено от родственников</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Рейтинг будет заполнен динамически -->
                </tbody>
            </table>
        </div>
        
        <div class="footer">
            Данные об именинах загружаются из <a href="https://github.com/kvloginov/namedays/blob/main/data/merged_namedays.json" target="_blank">репозитория namedays</a>
        </div>
    </div>

    <script>
        // Load namedays data
        let namedaysData;
        let chart;
        
        document.addEventListener('DOMContentLoaded', function() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const shareLinkEl = document.getElementById('share-link');
            
            loadingEl.style.display = 'block';
            
            // Use GitHub Raw URL to load JSON data
            // This URL allows direct access to the raw file content
            fetch('https://raw.githubusercontent.com/kvloginov/namedays/main/data/merged_namedays.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Ошибка загрузки данных: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    namedaysData = data;
                    console.log('Данные о именинах загружены:', namedaysData.length);
                    loadingEl.style.display = 'none';
                    
                    // Display today's namedays
                    displayTodayNamedays();
                    
                    // Check if URL has names parameter
                    loadNamesFromUrl();

                    // Setup for collapsibletoggle button for people editor
                    const togglePeopleEditorBtn = document.getElementById('toggle-people-editor-btn');
                    const peopleEditorCollapsible = document.getElementById('people-editor-collapsible');

                    if (togglePeopleEditorBtn && peopleEditorCollapsible) {
                        togglePeopleEditorBtn.addEventListener('click', () => {
                            if (peopleEditorCollapsible.style.display === 'none') {
                                peopleEditorCollapsible.style.display = 'block';
                                togglePeopleEditorBtn.textContent = 'Скрыть форму добавления людей';
                            } else {
                                peopleEditorCollapsible.style.display = 'none';
                                togglePeopleEditorBtn.textContent = 'Показать/редактировать список людей';
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Ошибка при загрузке данных:', error);
                    errorEl.textContent = `Не удалось загрузить данные: ${error.message}. Попробуйте обновить страницу.`;
                    errorEl.style.display = 'block';
                    loadingEl.style.display = 'none';
                });
            
            document.getElementById('generate-chart').addEventListener('click', generateChart);
            document.getElementById('share-button').addEventListener('click', shareNames);
        });
        
        // Counter for unique IDs for person cards
        let personIdCounter = 0;

        // Function to add a new person card to the input area
        function addPersonCard(personData = { name: '', surnameInitial: '', parents: [], grandparents: [] }) {
            personIdCounter++;
            const personCardId = `person-card-${personIdCounter}`;

            const card = document.createElement('div');
            card.classList.add('person-card');
            card.id = personCardId;

            card.innerHTML = 
                '<h4>Человек <span class="person-number">' + personIdCounter + '</span></h4>' +
                '<label for="person-name-' + personIdCounter + '">Имя:</label>' +
                '<input type="text" id="person-name-' + personIdCounter + '" class="person-name-input" placeholder="Имя человека" value="' + personData.name + '">' +
                '<label for="person-surname-initial-' + personIdCounter + '" style="margin-top: 5px;">Инициал (опц.):</label>' +
                '<input type="text" id="person-surname-initial-' + personIdCounter + '" class="person-surname-initial-input" placeholder="П." value="' + (personData.surnameInitial || '') + '" style="width: calc(50% - 22px);">' +

                '<div class="relatives-section">' +
                '    <h5>Родители:</h5>' +
                '    <div id="parents-list-' + personIdCounter + '" class="relatives-list"></div>' +
                '    <button type="button" class="add-relative-btn add-parent-btn" data-person-id="' + personIdCounter + '">+ Добавить родителя</button>' +
                '</div>' +

                '<div class="relatives-section">' +
                '    <h5>Бабушки и дедушки:</h5>' +
                '    <div id="grandparents-list-' + personIdCounter + '" class="relatives-list"></div>' +
                '    <button type="button" class="add-relative-btn add-grandparent-btn" data-person-id="' + personIdCounter + '">+ Добавить бабушку/дедушку</button>' +
                '</div>' +
                '<button type="button" class="remove-btn remove-person-btn" style="margin-top: 10px;" data-person-id="' + personIdCounter + '">Удалить этого человека</button>';

            document.getElementById('people-input-area').appendChild(card);

            // Add existing parents
            personData.parents.forEach(parentName => addRelativeInput(personIdCounter, 'parent', parentName));
            // Add existing grandparents
            personData.grandparents.forEach(grandparentName => addRelativeInput(personIdCounter, 'grandparent', grandparentName));


            // Event listeners for new buttons
            card.querySelector('.add-parent-btn').addEventListener('click', (e) => {
                addRelativeInput(e.target.dataset.personId, 'parent');
            });
            card.querySelector('.add-grandparent-btn').addEventListener('click', (e) => {
                addRelativeInput(e.target.dataset.personId, 'grandparent');
            });
            card.querySelector('.remove-person-btn').addEventListener('click', (e) => {
                removePersonCard(e.target.dataset.personId);
            });
        }

        // Function to add a relative input field (parent or grandparent)
        function addRelativeInput(personId, type, relativeName = '') {
            const listId = type === 'parent' ? `parents-list-${personId}` : `grandparents-list-${personId}`;
            const listElement = document.getElementById(listId);

            const relativeInputGroup = document.createElement('div');
            relativeInputGroup.classList.add('relative-input-group');
            
            const placeholder = type === 'parent' ? 'Имя родителя' : 'Имя бабушки/дедушки';
            const inputClass = type === 'parent' ? 'parent-name-input' : 'grandparent-name-input';

            relativeInputGroup.innerHTML = 
                '<input type="text" class="' + inputClass + '" placeholder="' + placeholder + '" value="' + relativeName + '">' +
                '<button type="button" class="remove-btn remove-relative-btn">-</button>';
            listElement.appendChild(relativeInputGroup);

            relativeInputGroup.querySelector('.remove-relative-btn').addEventListener('click', () => {
                relativeInputGroup.remove();
            });
        }

        // Function to remove a person card
        function removePersonCard(personId) {
            const card = document.getElementById(`person-card-${personId}`);
            if (card) {
                card.remove();
                // Renumber remaining cards (optional, for UI consistency)
                const remainingCards = document.querySelectorAll('.person-card');
                remainingCards.forEach((rcard, index) => {
                    rcard.querySelector('.person-number').textContent = index + 1;
                });
            }
        }
        
        document.getElementById('add-person-btn').addEventListener('click', () => addPersonCard());
        
        // Function to display today's namedays
        function displayTodayNamedays() {
            if (!namedaysData) {
                return;
            }
            
            // Get current date
            const today = new Date();
            const currentMonth = today.getMonth() + 1; // JS months are 0-based
            const currentDay = today.getDate();
            
            // Format current date as string for comparison
            const currentDateStr = `${currentMonth.toString().padStart(2, '0')}${currentDay.toString().padStart(2, '0')}`;
            
            // Find namedays for today
            const todayData = namedaysData.find(item => item.date === currentDateStr);
            
            const todayNamedaysEl = document.getElementById('today-namedays-list');
            
            if (todayData && todayData.names.length > 0) {
                todayNamedaysEl.textContent = todayData.names.join(', ') + '.';
            } else {
                todayNamedaysEl.textContent = 'Нет данных об именинах на сегодня.';
            }
        }
        
        // Function to encode names in base64
        function encodeNames(namesText) {
            // This function will need to be updated to handle the new data structure
            // For now, it's a placeholder for the old logic
            const peopleInputArea = document.getElementById('people-input-area');
            if (!peopleInputArea) return ''; // Should not happen

            const peopleCards = peopleInputArea.querySelectorAll('.person-card');
            const peopleData = [];

            peopleCards.forEach(card => {
                const personNameInput = card.querySelector('.person-name-input');
                const personName = personNameInput ? personNameInput.value.trim() : '';

                const surnameInitialInput = card.querySelector('.person-surname-initial-input');
                const surnameInitial = surnameInitialInput ? surnameInitialInput.value.trim() : '';

                if (personName) {
                    const person = {
                        name: personName,
                        surnameInitial: surnameInitial, 
                        parents: [],
                        grandparents: []
                    };

                    card.querySelectorAll('.parent-name-input').forEach(input => {
                        const parentName = input.value.trim();
                        if (parentName) person.parents.push(parentName);
                    });
                    card.querySelectorAll('.grandparent-name-input').forEach(input => {
                        const grandparentName = input.value.trim();
                        if (grandparentName) person.grandparents.push(grandparentName);
                    });
                    peopleData.push(person);
                }
            });
            
            if (peopleData.length === 0) return '';
            // Return a JSON string of an object containing peopleData and the checkbox state
            const includeRelatives = document.getElementById('include-relatives-checkbox').checked;
            const dataToEncode = {
                people: peopleData,
                includeRelatives: includeRelatives
            };
            return btoa(unescape(encodeURIComponent(JSON.stringify(dataToEncode))));
        }
        
        // Function to decode names from base64
        function decodeNames(encodedNames) {
            // This function will need to be updated to handle the new data structure
            // For now, it's a placeholder for the old logic
            try {
                const jsonString = decodeURIComponent(escape(atob(encodedNames)));
                const decodedData = JSON.parse(jsonString);
                // Return an object with people and includeRelatives properties
                return decodedData;
            } catch (e) {
                console.error('Ошибка при декодировании имён:', e);
                return { people: [], includeRelatives: true }; // Default to true if error
            }
        }
        
        // Function to share names via URL
        function shareNames() {
            // const namesInput = document.getElementById('names').value.trim(); // Old way
            // if (!namesInput) { // Old way
            //     alert('Пожалуйста, введите хотя бы одно имя.'); // Old way
            //     return; // Old way
            // }
            
            const encodedNames = encodeNames(); // New function call without args
            if (!encodedNames) {
                alert('Пожалуйста, добавьте хотя бы одного человека и введите его имя.');
                return;
            }
            
            // Create URL with names parameter
            const url = new URL(window.location.href);
            url.searchParams.set('names', encodedNames);
            
            // Update browser URL without reloading page
            window.history.pushState({}, '', url);
            
            // Show shareable link
            const shareLinkEl = document.getElementById('share-link');
            shareLinkEl.textContent = url.href;
            shareLinkEl.style.display = 'block';
            
            // Copy to clipboard
            navigator.clipboard.writeText(url.href)
                .then(() => {
                    alert('Ссылка скопирована в буфер обмена!');
                })
                .catch(err => {
                    console.error('Не удалось скопировать ссылку:', err);
                });
        }
        
        // Function to load names from URL and generate chart
        function loadNamesFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const encodedData = urlParams.get('names'); // The 'names' param now holds an object string
            
            if (encodedData) {
                const decodedDataObject = decodeNames(encodedData); // New logic, returns an object
                const peopleData = decodedDataObject.people;
                const includeRelatives = decodedDataObject.includeRelatives;

                if (peopleData && Array.isArray(peopleData)) {
                    // Clear any existing cards first
                    document.getElementById('people-input-area').innerHTML = '';
                    personIdCounter = 0; // Reset counter

                    peopleData.forEach(person => {
                        addPersonCard(person);
                    });

                    // If people were loaded from URL, collapse the editor by default
                    if (peopleData.length > 0) {
                        const peopleEditorCollapsible = document.getElementById('people-editor-collapsible');
                        const togglePeopleEditorBtn = document.getElementById('toggle-people-editor-btn');
                        if (peopleEditorCollapsible && togglePeopleEditorBtn) {
                            peopleEditorCollapsible.style.display = 'none';
                            togglePeopleEditorBtn.textContent = 'Показать/редактировать список людей';
                        }
                    }
                }
                // Set checkbox state
                document.getElementById('include-relatives-checkbox').checked = includeRelatives;
                
                // Generate chart if data is loaded
                if (namedaysData) {
                    generateChart();
                }
            }
        }
        
        function generateChart() {
            if (!namedaysData) {
                alert('Данные о именинах еще не загружены. Пожалуйста, подождите или обновите страницу.');
                return;
            }

            const peopleInputArea = document.getElementById('people-input-area');
            const peopleCards = peopleInputArea.querySelectorAll('.person-card');
            const peopleList = [];

            peopleCards.forEach(card => {
                const personNameInput = card.querySelector('.person-name-input');
                const personName = personNameInput ? personNameInput.value.trim() : '';

                const surnameInitialInput = card.querySelector('.person-surname-initial-input');
                const surnameInitial = surnameInitialInput ? surnameInitialInput.value.trim() : '';

                if (personName) {
                    const personData = {
                        name: personName,
                        surnameInitial: surnameInitial, 
                        parents: [],
                        grandparents: []
                    };
                    card.querySelectorAll('.parent-name-input').forEach(input => {
                        const parentName = input.value.trim();
                        if (parentName) personData.parents.push(parentName);
                    });
                    card.querySelectorAll('.grandparent-name-input').forEach(input => {
                        const grandparentName = input.value.trim();
                        if (grandparentName) personData.grandparents.push(grandparentName);
                    });
                    peopleList.push(personData);
                }
            });

            if (peopleList.length === 0) {
                alert('Пожалуйста, добавьте хотя бы одного человека и введите его имя.');
                return;
            }
            
            // Update URL with current names
            const encodedCurrentData = encodeNames(); // encodeNames now reads from the new structure and checkbox
            const url = new URL(window.location.href);
            url.searchParams.set('names', encodedCurrentData); // 'names' now stores the combined object
            window.history.pushState({}, '', url);
            
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            
            // Get current date
            const today = new Date();
            const currentMonth = today.getMonth() + 1; // JS months are 0-based
            const currentDay = today.getDate();
            
            // Format current date as string for comparison
            const currentDateStr = `${currentMonth.toString().padStart(2, '0')}${currentDay.toString().padStart(2, '0')}`;
            
            // Create an array of dates from the start of the year to the current date
            const dates = [];
            for (let month = 1; month <= 12; month++) {
                // Determine the number of days in the month
                const daysInMonth = new Date(today.getFullYear(), month, 0).getDate();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    // Stop when we reach the current date
                    if (month > currentMonth || (month === currentMonth && day > currentDay)) {
                        break;
                    }
                    
                    const dateStr = `${month.toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`;
                    dates.push(dateStr);
                }
            }
            
            // Prepare data for the chart
            const datasets = [];
            const rankingData = []; // For storing nameday counts for ranking
            
            // For each name, calculate the cumulative sum
            // names.forEach(name => { // Old loop
            peopleList.forEach(person => { // New loop
                let displayName = person.name;
                if (person.surnameInitial && person.surnameInitial.trim() !== '') {
                    displayName += ' ' + person.surnameInitial.trim(); // Display as entered, only trim whitespace
                }
                const name = displayName; // Use this for label and ranking
                const nameData = {
                    label: name, // Use person's combined name for the dataset label
                    data: [],
                    borderColor: getColorFromName(name),
                    backgroundColor: getColorFromName(name),
                    tension: 0.4,
                    pointRadius: 0, // Remove points
                    pointHoverRadius: 0, // Points don't appear and don't show on hover
                    borderWidth: 2, // Standard line thickness
                    hoverBorderWidth: 4, // Line thickness on hover
                    fill: false // Don't fill area under the line
                };
                
                let cumulativeSum = 0;
                let relativesScoreSum = 0; // Initialize relatives score sum
                let isTodayNameday = false; // For the main person
                const includeRelativesChecked = document.getElementById('include-relatives-checkbox').checked;
                let todayRelativesScore = 0; // Initialize today's relatives score
                
                dates.forEach(dateStr => {
                    let dailyScore = 0;
                    let dailyRelativesScore = 0; // Initialize daily relatives score
                    // Find if there are namedays for this day
                    const dayData = namedaysData.find(item => item.date === dateStr);
                    
                    if (dayData) {
                        // Check for main person's nameday (1 point)
                        const mainNameFound = dayData.names.some(nameInList => 
                            nameInList.toLowerCase().includes(person.name.toLowerCase()));
                        if (mainNameFound) {
                            dailyScore += 1;
                            if (dateStr === currentDateStr) {
                                isTodayNameday = true;
                            }
                        }

                        // Check for parents' namedays (0.5 points each) if checkbox is checked
                        if (includeRelativesChecked) {
                            person.parents.forEach(parentName => {
                                const parentNameFound = dayData.names.some(nameInList =>
                                    nameInList.toLowerCase().includes(parentName.toLowerCase()));
                                if (parentNameFound) {
                                    dailyScore += 0.5;
                                    dailyRelativesScore += 0.5;
                                }
                            });

                            // Check for grandparents' namedays (0.25 points each) if checkbox is checked
                            person.grandparents.forEach(grandparentName => {
                                const grandparentNameFound = dayData.names.some(nameInList =>
                                    nameInList.toLowerCase().includes(grandparentName.toLowerCase()));
                                if (grandparentNameFound) {
                                    dailyScore += 0.25;
                                    dailyRelativesScore += 0.25;
                                }
                            });
                        }
                    }
                    
                    cumulativeSum += dailyScore;
                    relativesScoreSum += dailyRelativesScore; // Accumulate relatives score
                    nameData.data.push(cumulativeSum);

                    // Store today's relatives score if this is today
                    if (dateStr === currentDateStr) {
                        todayRelativesScore = dailyRelativesScore;
                    }
                });
                
                datasets.push(nameData);
                
                // Add data for ranking table
                rankingData.push({
                    name: name, // Main person's combined name
                    count: cumulativeSum,
                    relativesScore: relativesScoreSum, // Add relatives score to ranking data
                    isTodayNameday: isTodayNameday, // Based on main person's nameday
                    todayRelativesScore: todayRelativesScore // Score from relatives today
                });
            });
            
            // Sort ranking data by count (descending)
            rankingData.sort((a, b) => b.count - a.count);
            
            // Update ranking table
            const rankingTableBody = document.querySelector('#nameday-ranking tbody');
            rankingTableBody.innerHTML = '';
            
            rankingData.forEach(item => {
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.textContent = item.name;
                
                const countCell = document.createElement('td');
                if (item.isTodayNameday || item.todayRelativesScore > 0) {
                    // Calculate total today's gain including relatives
                    const todayGain = (item.isTodayNameday ? 1 : 0) + item.todayRelativesScore;
                    countCell.textContent = `${item.count} (Сегодня +${todayGain})`;
                    countCell.classList.add('today-nameday');
                } else {
                    countCell.textContent = item.count;
                }

                const relativesScoreCell = document.createElement('td');
                // Get the checkbox state directly here as it's outside generateChart's direct scope for this part
                const isRelativesIncluded = document.getElementById('include-relatives-checkbox').checked;
                if (isRelativesIncluded && item.todayRelativesScore > 0) {
                    relativesScoreCell.textContent = `${item.relativesScore} (Сегодня +${item.todayRelativesScore})`;
                    relativesScoreCell.classList.add('today-nameday');
                } else {
                    relativesScoreCell.textContent = isRelativesIncluded ? item.relativesScore : 0;
                }
                
                row.appendChild(nameCell);
                row.appendChild(countCell);
                row.appendChild(relativesScoreCell); // Add new cell to the row
                rankingTableBody.appendChild(row);
            });
            
            // Format dates for the X-axis labels
            const formattedDates = dates.map(dateStr => {
                const month = parseInt(dateStr.substring(0, 2));
                const day = parseInt(dateStr.substring(2, 4));
                // Format as DD.MM with leading zeros
                return `${day.toString().padStart(2, '0')}.${month.toString().padStart(2, '0')}`;
            });
            
            // Dynamically calculate tick frequency for X-axis labels
            const numDates = formattedDates.length;
            const targetTickCount = numDates > 60 ? 15 : (numDates > 20 ? 10 : 5); // Aim for 5-15 ticks
            let step = 1;
            if (numDates > targetTickCount && targetTickCount > 0) {
                step = Math.ceil(numDates / targetTickCount);
            }
            if (numDates === 1) step = 1; // Ensure single date point is shown

            const labelIndices = [];
            if (numDates > 0) {
                for (let i = 0; i < numDates; i++) {
                    if (i % step === 0) {
                        labelIndices.push(i);
                    }
                }
                // Ensure the last label is always included if it wasn't captured by the step
                // and if there's more than one label and the last one isn't already in.
                if (numDates > 1 && (labelIndices.length === 0 || labelIndices[labelIndices.length - 1] !== numDates - 1)) {
                    if (labelIndices.length > 0 && labelIndices[labelIndices.length - 1] < numDates - 1) {
                         labelIndices.push(numDates - 1); // Add if not the very last and there's space
                    } else if (labelIndices.length === 0) {
                         labelIndices.push(numDates-1); // If no labels yet (e.g. step too large), add last
                    }
                }
                 // Special case for a single data point
                if (numDates === 1 && labelIndices.length === 0) {
                    labelIndices.push(0);
                }
            }
            
            // If the chart already exists, destroy it
            if (chart) {
                chart.destroy();
            }
            
            // Create a new chart
            const ctx = document.getElementById('namedays-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedDates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'dataset',
                        intersect: false,
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Накопительный график именин с начала года (с учетом родственников)',
                            font: {
                                size: 16
                            },
                            padding: {
                                top: 10,
                                bottom: 10
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            bodyFont: function(tooltipItem) {
                                const chart = tooltipItem.chart;
                                const activeElements = chart.getActiveElements();
                                let baseFont = Object.assign({}, chart.options.font); // Start with chart's default font

                                // Ensure baseFont has some defaults if chart.options.font is minimal
                                baseFont.size = baseFont.size || Chart.defaults.font.size;
                                baseFont.family = baseFont.family || Chart.defaults.font.family;
                                // baseFont.style = baseFont.style || Chart.defaults.font.style; // keep default style
                                baseFont.weight = baseFont.weight || Chart.defaults.font.weight; // keep default weight

                                if (activeElements.length > 0) {
                                    // If any element is active, make the body font bold
                                    baseFont.weight = 'bold';
                                    // Optionally, slightly increase size
                                    // baseFont.size = (baseFont.size || Chart.defaults.font.size) * 1.05; 
                                }
                                return baseFont;
                            },
                            callbacks: {
                                labelTextColor: function(tooltipItem) {
                                    const chart = tooltipItem.chart;
                                    // Get active elements based on the chart's interaction state
                                    const activeElements = chart.getActiveElements();

                                    if (activeElements.length > 0) {
                                        // Assuming interaction.mode = 'dataset' makes the first active element
                                        // the one corresponding to the hovered dataset.
                                        const hoveredDatasetIndex = activeElements[0].datasetIndex;

                                        if (tooltipItem.datasetIndex === hoveredDatasetIndex) {
                                            // This is the hovered dataset, use its border color
                                            if (chart.data.datasets[tooltipItem.datasetIndex]) {
                                                return chart.data.datasets[tooltipItem.datasetIndex].borderColor;
                                            }
                                            return '#000000'; // Fallback for highlighted item
                                        } else {
                                            // This is not the primarily hovered dataset, use a dimmer color
                                            return '#aaaaaa'; 
                                        }
                                    }
                                    // Default if no active elements or issues
                                    return '#333333'; // A slightly more visible default than pure #000
                                }
                            }
                        },
                        legend: {
                            display: false // Disable built-in legend, we'll use our custom one
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Даты'
                            },
                            ticks: {
                                callback: function(tickValue, index, ticks) {
                                    if (labelIndices.includes(index)) {
                                        if (index < formattedDates.length) {
                                            return formattedDates[index];
                                        }
                                    }
                                    return '';
                                }
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Количество дней с именинами (с учетом родственников)'
                            },
                            min: 0,
                            ticks: {
                                callback: function(value) { if (value % 1 === 0 || value % 0.5 === 0 || value % 0.25 === 0) { return value; } else { return undefined; } }
                            }
                        }
                    }
                }
            });
            
            loadingEl.style.display = 'none';
            
            // Create custom legend
            createCustomLegend(chart);
        }
        
        // Function to create custom legend
        function createCustomLegend(chart) {
            const legendContainer = document.getElementById('custom-legend');
            legendContainer.innerHTML = ''; // Clear container before updating
            
            const datasets = chart.data.datasets;
            
            datasets.forEach((dataset, index) => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('custom-legend-item');
                if (dataset.hidden) {
                    legendItem.classList.add('hidden');
                }
                
                const colorBox = document.createElement('div');
                colorBox.classList.add('custom-legend-color');
                colorBox.style.backgroundColor = dataset.borderColor;
                
                const labelText = document.createElement('div');
                labelText.classList.add('custom-legend-label');
                labelText.textContent = dataset.label;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(labelText);
                
                // Add click handler
                legendItem.addEventListener('click', (e) => {
                    const isShiftPressed = e.shiftKey;
                    
                    if (isShiftPressed) {
                        // Shift key pressed: Standard behavior (toggle one dataset)
                        datasets[index].hidden = !datasets[index].hidden;
                    } else {
                                                            // Check if this chart is the only one currently visible
                                    const isCurrentlyOnlyVisible = datasets.every((dataset, i) => 
                                        i === index ? !dataset.hidden : dataset.hidden);
                                    
                                    if (isCurrentlyOnlyVisible) {
                                        // If this is a second click on the same item, show all charts
                                        datasets.forEach(dataset => {
                                            dataset.hidden = false;
                                        });
                                    } else {
                                        // First click - show only the selected chart
                                        datasets.forEach((dataset, i) => {
                                            dataset.hidden = i !== index;
                                        });
                        }
                    }
                    
                    chart.update();
                    createCustomLegend(chart); // Update legend view after changes
                });
                
                legendContainer.appendChild(legendItem);
            });
        }
        
        // Function to generate a deterministic color based on name hash
        function getColorFromName(name) {
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = ((hash << 5) - hash) + name.charCodeAt(i);
                hash = hash & hash; // Convert to 32bit integer
            }
            
            // Use hash to generate HSL color with good saturation and lightness
            // This ensures colors are visually distinct but consistent for the same name
            const hue = Math.abs(hash) % 360;
            const saturation = 70 + (Math.abs(hash) % 30); // 70-100%
            const lightness = 45 + (Math.abs(hash) % 10);  // 45-55%
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
    </script>
</body>
</html> 